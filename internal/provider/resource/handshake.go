// Copyright 2024 Antimetal LLC
// SPDX-License-Identifier: MPL-2.0

package resource

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/antimetal/terraform-provider-antimetal/internal/antimetal"
)

const (
	operationCreate = "create"
	operationDelete = "delete"
)

var (
	_ resource.Resource              = &handshake{}
	_ resource.ResourceWithConfigure = &handshake{}
)

type handshakeModel struct {
	HandshakeID types.String `tfsdk:"handshake_id"`
	ExternalID  types.String `tfsdk:"external_id"`
	RoleARN     types.String `tfsdk:"role_arn"`
}

type handshake struct {
	client *antimetal.Client
}

func NewHandshake() resource.Resource {
	return &handshake{}
}

func (r *handshake) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_handshake"
}

func (r *handshake) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*antimetal.Client)
	if !ok {
		// This would be a programming error
		panic(
			fmt.Sprintf("Resource Handshake expects *provider/config.Config as ProviderData, "+
				"got: %T", req.ProviderData,
			),
		)
	}

	r.client = client
}

func (r *handshake) Schema(_ context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Attributes: map[string]schema.Attribute{
			"handshake_id": schema.StringAttribute{
				Required:    true,
				Description: "Unique Antimetal handshake identitifer.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"role_arn": schema.StringAttribute{
				Required:    true,
				Description: "arn of role Antimetal will use to connect to your AWS account.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"external_id": schema.StringAttribute{
				Required: true,
				Description: "generated by Antimetal to provide secure access to your AWS account. See " +
					"https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html " +
					"for more information.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (r *handshake) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	// No state to refresh.
	// Do nothing.
}

func (r *handshake) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan = &handshakeModel{}

	resp.Diagnostics.Append(req.Plan.Get(ctx, plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	handshake := convertToHandshake(plan, antimetal.HandshakeCreate)
	err := r.client.Handshake(handshake)
	if err != nil {
		addErrToDiagnostics(&resp.Diagnostics, err, operationCreate)
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

// Update should never be called since updating this resource should always result
// in a replace.
func (r *handshake) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	resp.Diagnostics.AddWarning(
		"Resource Update Considerations",
		"Updating this resource in place is not supported due to API limitations. "+
			"You will need to delete the old resource and create a new one",
	)
}

func (r *handshake) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	prevState := &handshakeModel{}

	resp.Diagnostics.Append(req.State.Get(ctx, prevState)...)
	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.Handshake(
		convertToHandshake(prevState, antimetal.HandshakeDelete),
	)

	addErrToDiagnostics(&resp.Diagnostics, err, operationDelete)
}

func convertToHandshake(data *handshakeModel, action antimetal.HandshakeAction) antimetal.HandshakeRequest {
	return antimetal.HandshakeRequest{
		Action:      action,
		HandshakeID: data.HandshakeID.ValueString(),
		ExternalID:  data.ExternalID.ValueString(),
		RoleARN:     data.RoleARN.ValueString(),
	}
}

func addErrToDiagnostics(d *diag.Diagnostics, err error, operation string) {
	if err == nil {
		return
	}

	d.AddError(
		fmt.Sprintf("API Error on %s", operation),
		fmt.Sprintf("... details ... %s", err),
	)
}
